一 缓冲区溢出：
    缓冲区溢出位置：堆栈 堆 bss
    
    1 覆盖栈中重要的变量，改变逻辑
    2 覆盖返回地址
        1）返回程序中的其他地址
        2）构造shellcode，执行自己的代码
            a）通过汇编使用al之类避免出现\x0
            b）通过替换\x0为特殊字符，比如‘#’,之后汇编之类单独提取参数

二 格式化字符串攻击
    printf传参是从右向左依次入栈，如printf(fmt,arg1,arg2...)。内部执行时：首先拿到fmt，然后依次冲栈顶开始，拿参数给fmt里对应的变量
    修改got表：plt跳转的时候，到got表里找函数地址

    1 读取任意存储地址的值（通过%x参数来递进，直到到达格式化字符串的其实地址，再以%x或%s获取对应地址的值）
    2 向任意地址写入（%n，它对应的val也是一个参数，跟arg*是一样按顺序入栈的，因此，只要把val的地址选好，就能实现了）
    3 直接参数访问（%n$[fmt]）

三 shellcode
    1 避免全零字节
        1）call指令中的0字节：jump and call(jump跳到一个高地址，然后call一个相对低一点地址，这个相对地址是小负数，前导位为1->0xff)
            E8 cd -> call rel32 
        2）更短的寄存器指令：ax al版本
        3）xor（sub可能修改寄存器flag，xor不会），inc，dec
        4) 通过esp指针获取字符串地址，从本质上避免了需要call/jump-and-call的获取字符串地址问题